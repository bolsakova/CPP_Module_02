=====================
 AD-HOC POLYMORPHISM
=====================
	- это когда одна и та же функция может работать с разными типами данных, но ведет себя по-разному для каждого типа. Компилятор сам решает какую функцию вызвать, основываясь на типах аргументов.

----- ЗАЧЕМ? -----
	- позволяет писать более гибкий код, где одни и те же операции работают с разными типами

======================
 OPERATOR OVERLOADING
======================
	- "научить" стандартные операторы (+,-,*,==,<< и т.д.) работать с вашими собственными классами.

----- ЗАЧЕМ? -----
	- делает классы более интуитивными в использовании (можно писать a+b вместо a.add(b))
	- удобство: перегрузка позволяет использовать стандартные оепраторы для работы  с пользовательскими типами данных
	- гибкость: можно определить, как операторы будут работать с вашими классами, чтобы они соответствовали вашим требованиям

----- КАК РАБОТАЕТ? -----
	Перегрузка оператора - это просто определение функции с использованием ключевого слова operator. Например, для перегрузки оператора + вы определяете функцию operator+.


===============================
 ORTHODOX CANONICAL CLASS FORM
===============================
	- это набор из 4 обяхательных методов, которые должны быть в каждом "правильном" классе:
		1. Default Constructor (конструктор по умолчанию - инициализирует значение в 0)
		2. Copy Constructor (конструктор копирования - копирует объект)
		3. Assignment Operator (оператор присваивания)
		4. Destructor (деструктор - уничтожает объект)

----- ЗАЧЕМ? -----
	- гарантирует, что ваши объекты правильно создаются, копируются и уничтожаются, избегая      утечек памяти и других проблем

=====================
 FIXED-POINT NUMBERS
=====================
	- (числа с фиксированной запятой) это способ представления дробных чисел, когда кол-во знаков после запятой всегда одинаковое (фиксированное).

----- В ЧЕМ ОТЛИЧИЕ ОТ FLOAT/DOUBLE? -----
	float/double	- числа с плавающей запятой: запятая может "плавать", т.е. число может
					  быть очень маленьким, но с определенной точностью
	fixed-point		- запятая всегда стоит на одном и том же месте (например, всегда 2 знака
					  после запятой)

----- КАК ЭТО РАБОТАЕТ В С++? -----
	Обычно fixed-point реализуют с помощью целых чисел и сдвига:
		- например, если у нас 8 бит под дробную часть, то число 1.5 будет храниться как
		  1.5 * 2^8 = 384

----- ПРЕИМУЩЕСТВА -----
	- быстрее и проще, чем float/double (особенно на микроконтроллерах)
	- нет ошибок округления, как у float (например, 0.1 + 0.2 не равно 0.3 в float)

----- НЕДОСТАТКИ -----
	- ограниченная точность (запятая не может "плавать")
	- нужно самому следить за масштабом (где стоит запятая)

----- ГДЕ ИСПОЛЬЗУЕТСЯ? -----
	- финансовые расчеты (деньги)
	- встраиваемые системы (микроконтроллеры)
	- там, где важна скорость и простота вычислений

----- КАК РАБОТАЕТ FIXED-POINT С 8 БИТАМИ? -----
	У нас есть 32-битное int число. Делим его на 2 части:
		- старшие 24 бита = целая часть
		- младшие 8 бит = дробная часть
	fixed_value = real_value * 2^8
	Пример: 
		Реальное число: 1.5
						↓ (умножаем на 2^8)
		Сырое значение: 384
						↓ (сохраняем в _fixedPointValue)
		В памяти: 0000 0001 1000 0000
				^^^^^^^^^ ^^^^^^^^^
				целая     дробная
				часть     часть

----- ЗАЧЕМ НУЖНЫ RAW BITS? -----
	- для отладки (посмотреть, что реально хранится)
	- для оптимизации (прямой доступ к внутреннему представлению)
	- для копирования без преобразований

----- ПРЕОБРАЗОВАНИЕ FLOAT -> FIXED-POINT -----
	Формула:
		fixed_value = (int)(float_value * (1 << 8))
			или
		fixed_value = (int)(float_value * 256)
	Пример:
		float value = 42.42f;
		int fixed = (int)(42.42f * 256) = (int)(10859.52) = 10859
	Зачем roundf()?
		Без округления, обрезает дробную часть:
			int fixed = (int)(42.42f * 256);
		С округлением (более точно), округляет к ближайшему:
			int fixed = (int)roundf(42.42f * 256);

----- ПРЕОБРАЗОВАНИЕ INT -> FIXED-POINT -----
	Формула:
		fixed_value = int_value << 8 (дробная часть всегда занимает младшие 8 бит)
			или
		fixed_value = int_value * 256
	Пример:
		int value = 10;
		int fixed = 10 << 8 = 10 * 256 = 2560

----- ПРЕОБРАЗОВАНИЕ FIXED-POINT -> FLOAT -----
	Формула:
		fixed_value = (float)fixed_value / (1 << 8)
			или
		fixed_value = (float)fixed_value / 256.0f
	Пример:
		int fixed = 10859; 								(Было 42.42)
		float value = (float)10859 / 256.0f = 42.418f	(Примерно 42.42)

----- ПРЕОБРАЗОВАНИЕ FIXED-POINT -> INT -----
	Формула:
		int_value = fixed_value >> 8
			или
		int_value = fixed_value / 256
